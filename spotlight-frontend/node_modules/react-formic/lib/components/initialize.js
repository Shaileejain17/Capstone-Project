'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _immutable = require('immutable');

var _rx = require('rx');

var _validity = require('../constants/validity');

var _objectUtils = require('../utils/objectUtils');

var _stateTypes = require('../data/stateTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function cleanValidationOutput(_ref) {
  var validity = _ref.validity;
  var validityMessage = _ref.validityMessage;

  return {
    validity: validity,
    validityMessage: validity === _validity.INVALID ? validityMessage : null
  };
}

function createTriggerFieldMap(fields) {
  return Object.keys(fields).filter(function (fieldName) {
    return fields[fieldName].triggerFields;
  }).reduce(function (acc, fieldName) {
    fields[fieldName].triggerFields.forEach(function (triggerFieldName) {
      acc[triggerFieldName].push(fieldName);
    });
    return acc;
  }, (0, _objectUtils.mapObjectToObject)(fields, function () {
    return [];
  }));
}

function createFieldValidationChangeHandlers(configFields, getFormState) {
  return (0, _objectUtils.mapObjectToObject)(configFields, function (field) {
    // let output;

    // if (field.validationStream) {
    //   const subject = new Subject();
    //   const validationStream = field.validationStream(subject, getFormState);
    //   output = {
    //     validationStream,
    //     onChange: value => subject.onNext(value),
    //   };
    // } else {
    //   output = null;
    // }

    var subject = new _rx.Subject();
    // const validationStream = field.validationStream(subject, getFormState);
    var output = {
      validationStream: field.validationStream ? field.validationStream(subject, getFormState) : null,
      onChange: function onChange(value) {
        return subject.onNext(value);
      }
    };

    return output;
  });
}

function createFieldValueChangeHandlers(fields) {
  return (0, _objectUtils.mapObjectToObject)(fields, function (field) {
    var subject = new _rx.Subject();
    return {
      valueStream: field.valueStream ? field.valueStream(subject) : subject,
      onChange: function onChange(value) {
        return subject.onNext(value);
      }
    };
  });
}

function triggerRelatedFields(relatedFields, fieldValidationChangeHandlers, formState, setFormField) {
  // Trigger other fields that need to know when this one changes
  relatedFields.forEach(function (fieldNameToTrigger) {
    // Set the field to dirty if it isn't already
    var fieldToTrigger = formState.getIn(['fields', fieldNameToTrigger]);
    if (!fieldNameToTrigger.isDirty) {
      setFormField({ fieldName: fieldNameToTrigger, field: { isDirty: true } });
    }

    // Trigger the field to revalidate with its current value
    fieldValidationChangeHandlers[fieldNameToTrigger].onChange(fieldToTrigger.value);
  });
}

function createEmptyForm(fields) {
  return new _stateTypes.Form({ fields: (0, _immutable.Map)((0, _objectUtils.mapObjectToObject)(fields, function () {
      return (0, _stateTypes.Field)();
    })) });
}

function getFieldsWithValueDiff(formState1, formState2) {
  return formState2.fields.reduce(function (acc, field, fieldName) {
    return !formState1 || field.value !== formState1.fields.get(fieldName).value ? acc.set(fieldName, field) : acc;
  }, (0, _immutable.Map)({}));
}

// --------------------------------------------------

function defaultMapFormToProps(formState) {
  return { form: formState };
}

function initialize(config) {
  var mapFormToProps = arguments.length <= 1 || arguments[1] === undefined ? defaultMapFormToProps : arguments[1];

  return function (ComponentToWrap) {
    var WrapperComponent = function (_React$Component) {
      _inherits(WrapperComponent, _React$Component);

      function WrapperComponent() {
        var _Object$getPrototypeO;

        var _temp, _this, _ret;

        _classCallCheck(this, WrapperComponent);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(WrapperComponent)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.getFormFieldState = function (fieldName) {
          return _this.props.formState.getIn(['fields', fieldName]);
        }, _this.getFormFieldChangeHandler = function (fieldName) {
          return _this.fieldValueChangeHandlers[fieldName].onChange;
        }, _this.getFormState = function () {
          return _this.props.formState;
        }, _temp), _possibleConstructorReturn(_this, _ret);
      }

      _createClass(WrapperComponent, [{
        key: 'getChildContext',
        value: function getChildContext() {
          return {
            getFormFieldState: this.getFormFieldState,
            getFormFieldChangeHandler: this.getFormFieldChangeHandler,
            getFormState: this.getFormState
          };
        }
      }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
          var _this2 = this;

          var _props = this.props;
          var formState = _props.formState;
          var setFormField = _props.setFormField;
          var initializeForm = _props.initializeForm;
          var fields = config.fields;
          var name = config.name;


          this.fieldValueChangeHandlers = createFieldValueChangeHandlers(fields);
          this.fieldValidationChangeHandlers = createFieldValidationChangeHandlers(fields, this.getFormState);
          this.triggerFieldMap = createTriggerFieldMap(fields);

          // Only create an empty formState if one doesn't already exist. State can persist after a
          // form unmounts if the reduxStateWrapper is being used.
          if (!formState) {
            initializeForm({ form: createEmptyForm(fields), formName: name });
          }

          // Create and register streams
          this.streams = [];

          // Set isRequired values on fields
          (0, _objectUtils.forEachPropertyOfObject)(config.fields, function (_ref2, fieldName) {
            var isRequired = _ref2.isRequired;

            setFormField({
              field: { isRequired: isRequired },
              fieldName: fieldName
            });
          });

          (0, _objectUtils.forEachPropertyOfObject)(this.fieldValueChangeHandlers, function (_ref3, fieldName) {
            var valueStream = _ref3.valueStream;

            _this2.registerStream(valueStream.subscribe(function (value) {
              return setFormField({
                field: { value: value, isDirty: true },
                fieldName: fieldName
              });
            }));
          });

          (0, _objectUtils.forEachPropertyOfObject)(this.fieldValidationChangeHandlers, function (validationChangeHandler, fieldName) {
            // eslint-disable-line
            // console.log('validationChangeHandler: ', validationChangeHandler);
            if (validationChangeHandler.validationStream) {
              _this2.registerStream(validationChangeHandler.validationStream.subscribe(function (value) {
                return setFormField({
                  field: cleanValidationOutput(value),
                  fieldName: fieldName
                });
              }));
            }
          });
        }
      }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
          var _this3 = this;

          // TODO Move this out into utility function
          getFieldsWithValueDiff(this.props.formState, nextProps.formState).filter(function (field) {
            return field.isDirty;
          }).forEach(function (_ref4, fieldName) {
            var value = _ref4.value;

            _this3.fieldValidationChangeHandlers[fieldName].onChange(value);

            triggerRelatedFields(_this3.triggerFieldMap[fieldName], _this3.fieldValidationChangeHandlers, nextProps.formState, _this3.props.setFormField);
          });
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          if (this.props.onUnmount) {
            this.props.onUnmount();
          }
          this.disposeStreams();
        }
      }, {
        key: 'registerStream',
        value: function registerStream(stream) {
          this.streams.push(stream);
        }
      }, {
        key: 'disposeStreams',
        value: function disposeStreams() {
          this.streams.forEach(function (stream) {
            return stream.dispose();
          });
        }
      }, {
        key: 'render',
        value: function render() {
          var formState = this.props.formState;

          // The first render happens before initialization has time to complete so only render
          // contents afterwards to avoid lots of conditional checking for state in sub components

          return formState ? _react2.default.createElement(ComponentToWrap, mapFormToProps(formState)) : null;
        }
      }]);

      return WrapperComponent;
    }(_react2.default.Component);

    WrapperComponent.propTypes = {
      formState: _react2.default.PropTypes.object,
      initializeForm: _react2.default.PropTypes.func.isRequired,
      onUnmount: _react2.default.PropTypes.func,
      setFormField: _react2.default.PropTypes.func.isRequired
    };
    WrapperComponent.childContextTypes = {
      getFormFieldState: _react2.default.PropTypes.func,
      getFormFieldChangeHandler: _react2.default.PropTypes.func,
      getFormState: _react2.default.PropTypes.func
    };


    return config.stateWrapper(WrapperComponent);
  };
}

exports.default = initialize;